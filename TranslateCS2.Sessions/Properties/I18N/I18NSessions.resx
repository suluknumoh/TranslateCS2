<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Caption" xml:space="preserve">
    <value>Session Management</value>
  </data>
  <data name="DialogDeleteText" xml:space="preserve">
    <value>Do you really want to delete the selected session?</value>
  </data>
  <data name="DialogDeleteTitle" xml:space="preserve">
    <value>delete selected session</value>
  </data>
  <data name="DoCancel" xml:space="preserve">
    <value>cancel</value>
  </data>
  <data name="DoCreate" xml:space="preserve">
    <value>create
new
session</value>
  </data>
  <data name="DoDelete" xml:space="preserve">
    <value>delete
selected
session</value>
  </data>
  <data name="DoEdit" xml:space="preserve">
    <value>edit
selected
session</value>
  </data>
  <data name="DoSave" xml:space="preserve">
    <value>save</value>
  </data>
  <data name="InputLocaleEnglish" xml:space="preserve">
    <value>localename in english</value>
  </data>
  <data name="InputLocaleEnglishTip" xml:space="preserve">
    <value>localename in english;
the drop down lists all supported (available in co's mscorlib AND mappable to a UnityEngine.SystemLanguage) languages english names

it is searchable
and
it is strongly recommended to select an appropriate english name, because the english name is also used to gather filename proposals for exports

selecting/changing the english name changes the localename localized respectively

below the drop down, the current english name is shown to provide backward-compatibility</value>
  </data>
  <data name="InputLocaleLocalized" xml:space="preserve">
    <value>localename localized</value>
  </data>
  <data name="InputLocaleLocalizedTip" xml:space="preserve">
    <value>localename localized;
the drop down lists all supported (available in co's mscorlib AND mappable to a UnityEngine.SystemLanguage) languages native names

it is searchable
as long as no english name is selected, selecting/changing the native name changes the localename in english respectively

the textbox below the drop down shows the current localename localized

it also allows you to specify your own name to use it while exporting via the add Key checkbox
especially for those who would like to create a slang/dialect

'Colognian'/'KÃ¶lsch' as an example for german</value>
  </data>
  <data name="InputMergeFile" xml:space="preserve">
    <value>localization file to merge with</value>
  </data>
  <data name="InputMergeFileTip" xml:space="preserve">
    <value>if you only want to change some translations,
tanslations within this file and yours are going to be merged;
or if you want to create a new translation e.g. based on english,
you'll get a mixed translation file;
should be another language than the ones you want to merge;</value>
  </data>
  <data name="InputName" xml:space="preserve">
    <value>name</value>
  </data>
  <data name="InputNameTip" xml:space="preserve">
    <value>a name for your translation session</value>
  </data>
  <data name="InputOverwriteFile" xml:space="preserve">
    <value>localization file to overwrite</value>
  </data>
  <data name="InputOverwriteFileTip" xml:space="preserve">
    <value>select none, if you only want to export as JSON

otherwise, the localization file you want to sacrifice/overwrite.
should be another language than english
and the ones you want to merge;
a language that you are unable to read/speak;
so you always have an ingame-fallback without the need to verify your installation files;</value>
  </data>
  <data name="InputSelectSession" xml:space="preserve">
    <value>translation sessions (selected ones is current)</value>
  </data>
  <data name="OutputAutoDetectedLocFiles" xml:space="preserve">
    <value>autodetected .loc-files</value>
  </data>
  <data name="OutputID" xml:space="preserve">
    <value>ID</value>
  </data>
  <data name="OutputInstallationDirectory" xml:space="preserve">
    <value>autodetected Cities: Skylines 2 - Installation Directory</value>
  </data>
  <data name="OutputLastEdited" xml:space="preserve">
    <value>last edited</value>
  </data>
  <data name="OutputStarted" xml:space="preserve">
    <value>started</value>
  </data>
</root>
